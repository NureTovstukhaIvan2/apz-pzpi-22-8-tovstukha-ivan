МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра програмної інженерії




Практична робота №2
з дисципліни
«Архітектура програмного забезпечення»






Виконав:                                                                                                  Перевірив                      
ст. гр. ПЗПІ-22-8                                                                      ст. викладач каф. ПІ
Товстуха Іван                                                                                     Сокорчук І. П.










Харків 2025
1 ІСТОРІЯ ЗМІН

№
Дата
Версія звіту
Опис змін та виправлень
1
24.03.2025
0.1
Створено розділ «Історія змін»
2
24.03.2025
0.1
Створено розділ «Завдання до практичної роботи»
3
24.03.2025
0.1
Створено розділ «Опис виконаної роботи»
4
24.03.2025
0.1
Створено розділ «Висновки»
5
24.03.2025
0.1
Додано додаток А з посиланням на відеоролик
6
24.03.2025
0.1
Додано додаток Б зі слайдами презентації
7
24.03.2025
0.1
Додано додаток В з програмним кодом
     Таблиця 1 - Історія змін
     
     
     
     2 ЗАВДАННЯ
     
     У рамках практичної роботи з дисципліни «Архітектура програмного забезпечення» було поставлено завдання дослідити архітектуру месенджера Telegram, зокрема її компоненти та принципи побудови. Метою роботи було розглянути основні аспекти архітектури Telegram, включаючи мікросервісну структуру, клієнтську та серверну частину, протокол MTProto, а також аспекти безпеки та масштабованості системи. Завдання передбачало глибоке розуміння технічних рішень, які забезпечують надійність і ефективність Telegram, а також їх інтеграцію в єдину розподілену архітектуру.



3 ОПИС ВИКОНАНОЇ РОБОТИ
     
     У процесі виконання роботи було здійснено аналіз архітектури Telegram, зокрема розглянуто мікросервісну модель, що є основою для високої масштабованості та гнучкості системи. Telegram побудований на принципах, які дозволяють йому ефективно обробляти великі обсяги трафіку і забезпечувати високу доступність для користувачів по всьому світу.
     Мікросервісна архітектура Telegram дозволяє розділити систему на окремі незалежні сервіси, кожен з яких відповідає за свою частину функціональності. Цей підхід дозволяє ефективно управляти різними аспектами роботи месенджера, такими як обробка повідомлень, зберігання медіафайлів, а також обробка запитів від ботів і користувачів. Кожен сервіс може бути розміщений на окремих серверах або в різних дата-центрах, що дозволяє зменшити затримки та забезпечити високу продуктивність.
     Особлива увага приділена протоколу MTProto, який є ключовим для забезпечення надійної і швидкої передачі даних між клієнтами та серверами. MTProto гарантує захищену передачу інформації через використання шифрування та механізмів автентифікації, що забезпечує високу безпеку даних навіть в умовах нестабільного інтернет-з'єднання. Протокол також оптимізований для роботи в умовах низької пропускної здатності, що робить Telegram доступним навіть у віддалених регіонах з поганим покриттям інтернетом.
     Що стосується клієнтської частини Telegram, то вона підтримує різні платформи, включаючи мобільні пристрої (iOS, Android), десктопні додатки та веб-версію. Архітектура клієнтської частини дозволяє швидко взаємодіяти з серверною частиною через API, застосовуючи модульний підхід для обробки повідомлень, медіафайлів і контактів. Це забезпечує зручність у використанні додатку і легкість масштабування.
     Ще одним важливим аспектом є безпека та конфіденційність користувачів. Telegram активно використовує шифрування на різних рівнях: від шифрування повідомлень до захисту серверної інфраструктури. Всі дані, що передаються через мережу, зашифровані за допомогою технології end-to-end, що гарантує, що тільки відправник і отримувач можуть отримати доступ до змісту повідомлення. Telegram також використовує механізми двофакторної автентифікації для підвищення безпеки облікових записів.
     Для досягнення високої надійності і масштабованості Telegram використовує розподілену архітектуру зберігання даних, що дозволяє зберігати інформацію на декількох географічно розподілених серверах. Це забезпечує швидкий доступ до даних і знижує ризик втрати інформації. Також система підтримує реплікацію даних, що дозволяє уникнути збоїв у разі відмови окремих серверів.
     Всі ці аспекти забезпечують Telegram стабільну роботу, високу швидкість обробки запитів, надійність і безпеку, що робить месенджер ефективним інструментом для комунікації в умовах високих навантажень.
     
     
     
4 ВИСНОВКИ З РОБОТИ
     
     Аналіз архітектури Telegram показав, що цей месенджер побудований на основі сучасних принципів мікросервісної архітектури, що дозволяє ефективно масштабувати систему та забезпечувати її високу надійність і безпеку. Використання протоколу MTProto гарантує швидку і захищену передачу даних навіть при поганих умовах зв'язку, а система реплікації та балансування навантаження забезпечує безперервну роботу додатку при великих обсягах трафіку.
     Telegram використовує модульну структуру, що дозволяє легко масштабувати окремі компоненти системи і підтримувати їх незалежність. Крім того, значна увага приділяється безпеці, що включає шифрування даних і використання двофакторної автентифікації для захисту акаунтів користувачів.
     В цілому, архітектура Telegram є надійною і високопродуктивною, здатною ефективно обслуговувати мільйони користувачів по всьому світу. Вона демонструє передові технологічні рішення для створення месенджера, який забезпечує високу якість обслуговування користувачів навіть в умовах високих навантажень.


     ДОДАТОК А
     Відеозапис доповіді на YouTube: https://youtu.be/9_zOJ8Pmle0
     00:00 Вступ: 
     00:11 Загальна архітектура системи: 
     01:05 Мікросервісна архітектура: 
     02:00 Клієнтська частина: 
     02:45 Протокол MTProto: 
     03:32 Реалізація протоколу MTProto: 
     04:39 Серверна частина: 
     05:24 Архітектура оптимізації даних: 
     06:27 Розподілена архітектура зберігання даних: 
     07:28 Масштабованість і надійність: 
     08:30 Безпека та конфіденційність: 
     09:26 Висновок презентації:
     
     ДОДАТОК Б
     Слайди презентації доповіді


Рисунок Б.1 – Титульний слайд презентації


Рисунок Б.2 – Загальна архітектура системи


Рисунок Б.3 –Мікросервісна архітектура


Рисунок Б.4 – Клієнтська частина


Рисунок Б.5 – Протокол MTProto


Рисунок Б.6 – Реалізація протоколу MTProto


Рисунок Б.7 – Серверна частина


Рисунок Б.8 – Архітектура оптимізації даних


Рисунок Б.9 – Розподілена архітектура зберігання даних


Рисунок Б.10 – Масштабованість і надійність


Рисунок Б.11 – Безпека та конфіденційність


Рисунок Б.12 – Висновок презентації


     ДОДАТОК В
     Програмний код
     
     1.  # Генерація ключа для симетричного шифрування (AES)
     2.  def generate_symmetric_key():
     3.      return get_random_bytes(32)  # 256 біт для AES
     4.  
     5.  # Шифрування повідомлення за допомогою AES
     6.  def encrypt_message(key, message):
     7.      cipher = AES.new(key, AES.MODE_CBC)
     8.      ciphertext = cipher.encrypt(pad(message.encode(), AES.block_size))
     9.      return cipher.iv + ciphertext  # Повертаємо IV разом з шифрованим повідомленням
     10. 
     11. # Розшифрування повідомлення
     12. def decrypt_message(key, encrypted_message):
     13.     iv = encrypted_message[:16]  # Перші 16 байт - IV
     14.     ciphertext = encrypted_message[16:]
     15.     cipher = AES.new(key, AES.MODE_CBC, iv)
     16.     return unpad(cipher.decrypt(ciphertext), AES.block_size).decode()
     17. 
     18. # Генерація пари ключів RSA
     19. def generate_rsa_keys():
     20.     key = RSA.generate(2048)
     21.     private_key = key.export_key()
     22.     public_key = key.publickey().export_key()
     23.     return private_key, public_key
     24. 
     25. # Підписування повідомлення за допомогою RSA
     26. def sign_message(private_key, message):
     27.     key = RSA.import_key(private_key)
     28.     h = hashlib.sha256(message.encode()).digest()
     29.     signature = pkcs1_15.new(key).sign(h)
     30.     return signature
     31. 
     32. # Перевірка підпису повідомлення
     33. def verify_signature(public_key, message, signature):
     34.     key = RSA.import_key(public_key)
     35.     h = hashlib.sha256(message.encode()).digest()
     36.     try:
     37.         pkcs1_15.new(key).verify(h, signature)
     38.         return True
     39.     except (ValueError, TypeError):
     40.         return False
     41. 
     42. def mtproto_logic():
     43.     # Генерація ключів
     44.     symmetric_key = generate_symmetric_key()
     45.     private_key, public_key = generate_rsa_keys()
     46. 
     47.     # Оригінальне повідомлення
     48.     message = "MTProto message!"
     49. 
     50.     # Шифрування повідомлення
     51.     encrypted_message = encrypt_message(symmetric_key, message)
     52.     print("Encrypted Message:", encrypted_message)
     53. 
     54.     # Розшифрування повідомлення
     55.     decrypted_message = decrypt_message(symmetric_key, encrypted_message)
     56.     print("Decrypted Message:", decrypted_message)
     57. 
     58.     # Підписування повідомлення
     59.     signature = sign_message(private_key, message)
     60.     print("Message Signature:", signature)
     61. 
     62.     # Перевірка підпису
     63.     is_valid = verify_signature(public_key, message, signature)
     64.     print("Signature valid:", is_valid)
